<!DOCTYPE html>
<html>
<head>
    <title>Platform Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let player = {
            x: 100,
            y: 100,
            radius: 20,
            vx: 0,
            vy: 0,
            onGround: false,
            lives: 3,
            scale: 1
        };

        let platforms = [];
        let stars = [];
        let enemies = [];
        let score = 0;
        let level = 1;
        let gameState = 'playing';
        let exitPlatform = null;
        let platformSpeed = 1;
        let bgColors = [];

        // Key states
        const keys = {
            left: false,
            right: false,
            space: false
        };

        // Constants
        const GRAVITY = 0.5;
        const JUMP_FORCE = -10;
        const MOVE_SPEED = 3;
        const PLATFORM_COUNT = 10;
        const STAR_COUNT = 5;
        const ENEMY_COUNT = 3;
        const BOUNCE_FACTOR = 0.3;

        function generateBackgroundColors() {
            const hue = Math.floor(Math.random() * 360);
            return [
                `hsl(${hue}, 70%, 15%)`,
                `hsl(${(hue + 30) % 360}, 70%, 25%)`
            ];
        }

        function initGame() {
            player.x = 100;
            player.y = 100;
            player.vx = 0;
            player.vy = 0;
            player.scale = 1;
            
            platforms = [];
            stars = [];
            enemies = [];
            exitPlatform = null;
            
            // Background colors
            bgColors = generateBackgroundColors();
            
            // Create starting platform
            platforms.push({
                x: 50,
                y: 150,
                width: 200,
                height: 20,
                color: 'darkgreen',
                vx: 0,
                direction: 1
            });
            
            // Create moving platforms
            const platformHeight = 20;
            const availableHeight = canvas.height - 200;
            const platformSpacing = Math.min(player.radius * 6, availableHeight / PLATFORM_COUNT);
            
            for (let i = 0; i < PLATFORM_COUNT; i++) {
                const width = Math.random() * 200 + 100;
                const x = Math.random() * (canvas.width - width);
                const y = 200 + i * platformSpacing;
                
                platforms.push({
                    x,
                    y,
                    width,
                    height: platformHeight,
                    color: 'darkblue',
                    vx: (Math.random() * 2 + 1) * platformSpeed,
                    direction: Math.random() > 0.5 ? 1 : -1
                });
            }
            
            // Create death platform
            platforms.push({
                x: 0,
                y: canvas.height - 20,
                width: canvas.width,
                height: 20,
                color: 'red',
                vx: 0,
                direction: 1,
                deadly: true
            });
            
            // Create stars
            const upperLimit = canvas.height * 2/3;
            for (let i = 0; i < STAR_COUNT; i++) {
                let valid = false;
                let starX, starY;
                
                while (!valid) {
                    starX = Math.random() * (canvas.width - 40) + 20;
                    starY = Math.random() * (upperLimit - 200) + 200;
                    valid = true;
                    
                    // Check if star is not on top of an enemy
                    for (const enemy of enemies) {
                        const dx = starX - enemy.x;
                        const dy = starY - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 40) {
                            valid = false;
                            break;
                        }
                    }
                }
                
                stars.push({
                    x: starX,
                    y: starY,
                    radius: 15,
                    scale: 1,
                    collected: false
                });
            }
            
            // Create enemies
            for (let i = 0; i < ENEMY_COUNT; i++) {
                const platformIndex = Math.floor(Math.random() * (PLATFORM_COUNT - 1)) + 1;
                const platform = platforms[platformIndex];
                
                enemies.push({
                    x: platform.x + platform.width / 2,
                    y: platform.y - 15,
                    size: 20,
                    platformIndex
                });
            }
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.scale(player.scale, player.scale);
            
            // Draw player with gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius);
            gradient.addColorStop(0, 'lightblue');
            gradient.addColorStop(1, 'white');
            
            ctx.beginPath();
            ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'black';
            ctx.stroke();
            
            ctx.restore();
        }

        function drawPlatform(platform) {
            const gradient = ctx.createLinearGradient(
                platform.x, platform.y,
                platform.x, platform.y + platform.height
            );
            gradient.addColorStop(0, platform.color);
            gradient.addColorStop(1, adjustColor(platform.color, -30));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
        }

        function drawStar(star) {
            ctx.save();
            ctx.translate(star.x, star.y);
            ctx.scale(star.scale, star.scale);
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, star.radius);
            gradient.addColorStop(0, 'yellow');
            gradient.addColorStop(1, 'gold');
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                const outerX = Math.cos(angle) * star.radius;
                const outerY = Math.sin(angle) * star.radius;
                
                const innerAngle = angle + Math.PI / 5;
                const innerX = Math.cos(innerAngle) * (star.radius / 2);
                const innerY = Math.sin(innerAngle) * (star.radius / 2);
                
                if (i === 0) {
                    ctx.moveTo(outerX, outerY);
                } else {
                    ctx.lineTo(outerX, outerY);
                }
                
                ctx.lineTo(innerX, innerY);
            }
            ctx.closePath();
            
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }

        function drawEnemy(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, enemy.size);
            gradient.addColorStop(0, 'red');
            gradient.addColorStop(1, 'darkred');
            
            ctx.beginPath();
            ctx.moveTo(0, -enemy.size);
            ctx.lineTo(enemy.size, enemy.size);
            ctx.lineTo(-enemy.size, enemy.size);
            ctx.closePath();
            
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, bgColors[0]);
            gradient.addColorStop(1, bgColors[1]);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 20, 30);
            ctx.fillText(`Level: ${level}`, 20, 60);
            ctx.fillText(`Lives: ${player.lives}`, 20, 90);
            
            if (gameState === 'levelComplete') {
                ctx.fillStyle = 'white';
                ctx.font = '30px Arial';
                const text = `Get ready for level: ${level}`;
                const textWidth = ctx.measureText(text).width;
                ctx.fillText(text, (canvas.width - textWidth) / 2, canvas.height / 2);
                ctx.fillText('Press SPACE to continue', (canvas.width - ctx.measureText('Press SPACE to continue').width) / 2, canvas.height / 2 + 40);
            } else if (gameState === 'gameOver') {
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                const text = 'GAME OVER';
                const textWidth = ctx.measureText(text).width;
                ctx.fillText(text, (canvas.width - textWidth) / 2, canvas.height / 2);
                ctx.font = '30px Arial';
                ctx.fillText('Press SPACE to restart', (canvas.width - ctx.measureText('Press SPACE to restart').width) / 2, canvas.height / 2 + 50);
            }
        }

        function drawExitPlatform() {
            if (exitPlatform) {
                const gradient = ctx.createLinearGradient(
                    exitPlatform.x, exitPlatform.y,
                    exitPlatform.x, exitPlatform.y + exitPlatform.height
                );
                gradient.addColorStop(0, 'darkgreen');
                gradient.addColorStop(1, 'green');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(exitPlatform.x, exitPlatform.y, exitPlatform.width, exitPlatform.height);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeRect(exitPlatform.x, exitPlatform.y, exitPlatform.width, exitPlatform.height);
                
                ctx.fillStyle = 'yellow';
                ctx.font = '20px Arial';
                ctx.fillText('EXIT', exitPlatform.x + exitPlatform.width / 2 - 25, exitPlatform.y + exitPlatform.height / 2 + 7);
            }
        }

        function adjustColor(color, amount) {
            if (color.startsWith('rgb')) return color;
            
            const colors = {
                'red': '#ff0000',
                'darkred': '#8b0000',
                'darkgreen': '#006400',
                'darkblue': '#00008b',
                'green': '#008000',
                'yellow': '#ffff00',
                'gold': '#ffd700'
            };
            
            let hex = colors[color] || color;
            
            if (hex.startsWith('#')) {
                hex = hex.slice(1);
            }
            
            let r = parseInt(hex.slice(0, 2), 16);
            let g = parseInt(hex.slice(2, 4), 16);
            let b = parseInt(hex.slice(4, 6), 16);
            
            r = Math.max(0, Math.min(255, r + amount));
            g = Math.max(0, Math.min(255, g + amount));
            b = Math.max(0, Math.min(255, b + amount));
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function updatePlayer() {
            // Apply horizontal movement
            if (keys.left) player.vx = -MOVE_SPEED;
            else if (keys.right) player.vx = MOVE_SPEED;
            else player.vx *= 0.9;
            
            // Apply gravity
            player.vy += GRAVITY;
            
            // Apply jump
            if (keys.space && player.onGround) {
                player.vy = JUMP_FORCE;
                player.onGround = false;
            }
            
            // Update position
            player.x += player.vx;
            player.y += player.vy;
            
            // Screen boundaries
            if (player.x < player.radius) {
                player.x = player.radius;
                player.vx = 0;
            } else if (player.x > canvas.width - player.radius) {
                player.x = canvas.width - player.radius;
                player.vx = 0;
            }
            
            // Check platform collisions
            player.onGround = false;
            for (const platform of platforms) {
                if (player.y + player.radius > platform.y && 
                    player.y - player.radius < platform.y + platform.height &&
                    player.x + player.radius > platform.x &&
                    player.x - player.radius < platform.x + platform.width) {
                    
                    // Top collision (landing)
                    if (player.vy > 0 && player.y + player.radius - player.vy <= platform.y) {
                        player.y = platform.y - player.radius;
                        player.vy = -player.vy * BOUNCE_FACTOR;
                        player.onGround = true;
                        player.x += platform.vx * platform.direction;
                        
                        // Check if death platform
                        if (platform.deadly) {
                            playerDie();
                        }
                    }
                }
            }
            
            // Check exit platform
            if (exitPlatform && 
                player.y + player.radius > exitPlatform.y && 
                player.y - player.radius < exitPlatform.y + exitPlatform.height &&
                player.x + player.radius > exitPlatform.x &&
                player.x - player.radius < exitPlatform.x + exitPlatform.width) {
                
                if (player.vy > 0 && player.y + player.radius - player.vy <= exitPlatform.y) {
                    nextLevel();
                }
            }
            
            // Check star collisions
            for (let i = 0; i < stars.length; i++) {
                if (!stars[i].collected) {
                    const dx = player.x - stars[i].x;
                    const dy = player.y - stars[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.radius + stars[i].radius * stars[i].scale) {
                        stars[i].collected = true;
                        score++;
                        
                        // Check if all stars collected
                        if (stars.every(star => star.collected)) {
                            createExitPlatform();
                        }
                    }
                }
            }
            
            // Check enemy collisions
            for (const enemy of enemies) {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.radius + enemy.size) {
                    playerDie();
                }
            }
            
            // Check if fallen off screen
            if (player.y > canvas.height + 100) {
                playerDie();
            }
        }

        function updatePlatforms() {
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                
                if (platform.vx > 0) {
                    platform.x += platform.vx * platform.direction;
                    
                    // Reverse direction at edges
                    if (platform.x <= 0 || platform.x + platform.width >= canvas.width) {
                        platform.direction *= -1;
                    }
                }
            }
        }

        function updateEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const platform = platforms[enemy.platformIndex];
                
                // Move with platform
                enemy.x += platform.vx * platform.direction;
                
                // Keep enemy on platform
                if (enemy.x < platform.x + enemy.size) {
                    enemy.x = platform.x + enemy.size;
                } else if (enemy.x > platform.x + platform.width - enemy.size) {
                    enemy.x = platform.x + platform.width - enemy.size;
                }
            }
        }

        function updateStars() {
            for (let i = 0; i < stars.length; i++) {
                if (stars[i].collected) {
                    stars[i].scale -= 0.05;
                    if (stars[i].scale <= 0) {
                        stars[i].scale = 0;
                    }
                }
            }
        }

        function createExitPlatform() {
            exitPlatform = {
                x: canvas.width - 200,
                y: canvas.height - 150,
                width: 150,
                height: 20
            };
        }

        function playerDie() {
            player.lives--;
            
            if (player.lives <= 0) {
                gameState = 'gameOver';
            } else {
                // Reset player position
                player.x = 100;
                player.y = 100;
                player.vx = 0;
                player.vy = 0;
            }
        }

        function nextLevel() {
            level++;
            score += 5;
            platformSpeed += 0.2;
            gameState = 'levelComplete';
        }

        function update() {
            if (gameState === 'playing') {
                updatePlayer();
                updatePlatforms();
                updateEnemies();
                updateStars();
            }
        }

        function draw() {
            drawBackground();
            
            // Draw platforms
            for (const platform of platforms) {
                drawPlatform(platform);
            }
            
            // Draw exit platform
            drawExitPlatform();
            
            // Draw stars
            for (const star of stars) {
                if (star.scale > 0) {
                    drawStar(star);
                }
            }
            
            // Draw enemies
            for (const enemy of enemies) {
                drawEnemy(enemy);
            }
            
            // Draw player
            drawPlayer();
            
            // Draw UI
            drawUI();
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            update();
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === ' ') {
                keys.space = true;
                
                if (gameState === 'levelComplete' || gameState === 'gameOver') {
                    if (gameState === 'gameOver') {
                        level = 1;
                        score = 0;
                        player.lives = 3;
                        platformSpeed = 1;
                    }
                    
                    gameState = 'playing';
                    initGame();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === ' ') keys.space = false;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGame();
        });

        // Start game
        initGame();
        gameLoop();
    </script>
</body>
</html>
