<!DOCTYPE html>
<html>
<head>
    <title>Platform Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Game state
    let player = {
        x: 100, y: 100, radius: 15, vx: 0, vy: 0, 
        onGround: false, lives: 3, jumping: false
    };
    let platforms = [];
    let stars = [];
    let enemies = [];
    let score = 0;
    let level = 1;
    let gameState = 'playing';
    let exitPlatform = null;
    let platformSpeed = 1;
    let bgColors = [];
    
    // Controls
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    // Initialize game
    function init() {
        // Background gradient colors for different levels
        bgColors = [
            { top: '#0a0a2a', bottom: '#4a1030' },  // Night dawn
            { top: '#1a1a4a', bottom: '#6a2050' },  // Deeper blue-purple
            { top: '#2a2a6a', bottom: '#8a3070' },  // Rich purple
            { top: '#3a3a8a', bottom: '#aa4090' },  // Vibrant purple
            { top: '#4a4aaa', bottom: '#ca50b0' }   // Bright purple-pink
        ];
        
        // Reset player
        player.x = 100;
        player.y = 100;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
        if (gameState === 'gameOver') player.lives = 3;
        player.jumping = false;
        
        // Create platforms
        platforms = [];
        // Starting platform (dark green, static)
        platforms.push({
            x: 50, y: 150, width: 150, height: 20, 
            color: '#005500', moving: false, direction: 1, speed: 0
        });
        
        // Moving platforms (dark blue)
        const platformCount = 10;
        const screenHeight = canvas.height - 100;
        const jumpHeight = 120;
        const sectionHeight = screenHeight / platformCount;
        
        for (let i = 1; i < platformCount; i++) {
            const y = 150 + i * sectionHeight;
            const width = 80 + Math.random() * 200;
            platforms.push({
                x: Math.random() * (canvas.width - width),
                y: y,
                width: width,
                height: 20,
                color: '#00008B',
                moving: true,
                direction: Math.random() > 0.5 ? 1 : -1,
                speed: platformSpeed
            });
        }
        
        // Bottom red gutter (kill zone)
        platforms.push({
            x: 0, y: canvas.height - 20, width: canvas.width, height: 20,
            color: '#FF0000', moving: false, direction: 1, speed: 0, isDeadly: true
        });
        
        // Create stars
        stars = [];
        const starCount = 5 + level;
        const safeZone = canvas.height * 2/3;
        
        for (let i = 0; i < starCount; i++) {
            stars.push({
                x: 50 + Math.random() * (canvas.width - 100),
                y: 50 + Math.random() * safeZone,
                radius: 15,
                collected: false,
                scale: 1
            });
        }
        
        // Create enemies
        enemies = [];
        const enemyCount = 2 + Math.min(level, 3);
        
        for (let i = 0; i < enemyCount; i++) {
            const platformIndex = 1 + Math.floor(Math.random() * (platforms.length - 2));
            const platform = platforms[platformIndex];
            
            enemies.push({
                x: platform.x + platform.width / 2,
                y: platform.y - 15,
                size: 20,
                platformIndex: platformIndex
            });
        }
        
        // No exit platform initially
        exitPlatform = null;
        
        // Set game state
        if (gameState === 'gameOver') {
            score = 0;
            level = 1;
            platformSpeed = 1;
        }
        gameState = 'playing';
    }

    function update() {
        if (gameState === 'playing') {
            updatePlayer();
            updatePlatforms();
            updateStars();
            updateEnemies();
            checkCollisions();
            checkGameProgress();
        } else if (gameState === 'levelComplete' && keys['Space']) {
            level++;
            platformSpeed += 0.2;
            init();
            gameState = 'playing';
        } else if (gameState === 'gameOver' && keys['Space']) {
            init();
        }
    }

    function updatePlayer() {
        // Horizontal movement
        if (keys['ArrowLeft']) player.vx = Math.max(player.vx - 0.5, -5);
        else if (keys['ArrowRight']) player.vx = Math.min(player.vx + 0.5, 5);
        else player.vx *= 0.9;
        
        // Jumping
        if (keys['Space'] && player.onGround && !player.jumping) {
            player.vy = -10;
            player.jumping = true;
            player.onGround = false;
        }
        
        // Apply gravity
        if (!player.onGround) player.vy += 0.5;
        
        // Update position
        player.x += player.vx;
        player.y += player.vy;
        
        // Screen boundaries
        if (player.x < player.radius) player.x = player.radius;
        if (player.x > canvas.width - player.radius) player.x = canvas.width - player.radius;
        
        // Reset jumping flag when falling
        if (player.vy > 0) player.jumping = false;
        
        // Default to not on ground
        player.onGround = false;
    }

    function updatePlatforms() {
        platforms.forEach(platform => {
            if (platform.moving) {
                platform.x += platform.direction * platform.speed;
                if (platform.x <= 0 || platform.x + platform.width >= canvas.width) {
                    platform.direction *= -1;
                }
            }
        });
    }

    function updateStars() {
        stars.forEach(star => {
            if (star.collected) {
                star.scale -= 0.1;
            }
        });
        stars = stars.filter(star => !star.collected || star.scale > 0);
    }

    function updateEnemies() {
        enemies.forEach(enemy => {
            const platform = platforms[enemy.platformIndex];
            enemy.x = platform.x + platform.width / 2;
        });
    }

    function checkCollisions() {
        // Platform collisions
        let wasOnGround = player.onGround;
        player.onGround = false;
        
        platforms.forEach(platform => {
            if (player.x + player.radius > platform.x && 
                player.x - player.radius < platform.x + platform.width &&
                player.y + player.radius > platform.y && 
                player.y - player.radius < platform.y + platform.height) {
                
                // Top collision (landing)
                if (player.vy > 0 && player.y < platform.y) {
                    player.y = platform.y - player.radius;
                    player.vy = wasOnGround ? player.vy * -0.3 : 0; // Bounce effect
                    player.onGround = true;
                    
                    // Move with platform
                    if (platform.moving) {
                        player.x += platform.direction * platform.speed;
                    }
                    
                    // Check if deadly platform or exit
                    if (platform.isDeadly) {
                        playerDie();
                    } else if (platform === exitPlatform) {
                        gameState = 'levelComplete';
                    }
                }
            }
        });
        
        // Star collisions
        stars.forEach(star => {
            if (!star.collected) {
                const dx = player.x - star.x;
                const dy = player.y - star.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.radius + star.radius) {
                    star.collected = true;
                    score += 1;
                }
            }
        });
        
        // Enemy collisions
        enemies.forEach(enemy => {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < player.radius + enemy.size / 2) {
                playerDie();
            }
        });
    }

    function checkGameProgress() {
        // Check if all stars collected
        if (stars.every(star => star.collected) && !exitPlatform) {
            // Create exit platform
            exitPlatform = {
                x: canvas.width - 200,
                y: canvas.height - 100,
                width: 150,
                height: 20,
                color: '#005500',
                moving: false,
                direction: 1,
                speed: 0,
                isExit: true
            };
            platforms.push(exitPlatform);
        }
    }

    function playerDie() {
        player.lives--;
        if (player.lives <= 0) {
            gameState = 'gameOver';
        } else {
            // Reset player position
            player.x = 100;
            player.y = 100;
            player.vx = 0;
            player.vy = 0;
        }
    }

    function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw background
        const bgIndex = (level - 1) % bgColors.length;
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, bgColors[bgIndex].top);
        gradient.addColorStop(1, bgColors[bgIndex].bottom);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw platforms
        platforms.forEach(platform => {
            // Platform gradient
            const platformGradient = ctx.createRadialGradient(
                platform.x + platform.width/2, platform.y + platform.height/2, 5,
                platform.x + platform.width/2, platform.y + platform.height/2, platform.width/2
            );
            platformGradient.addColorStop(0, lightenColor(platform.color, 30));
            platformGradient.addColorStop(1, platform.color);
            
            ctx.fillStyle = platformGradient;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.rect(platform.x, platform.y, platform.width, platform.height);
            ctx.fill();
            ctx.stroke();
            
            // Draw "EXIT" text on exit platform
            if (platform.isExit) {
                ctx.fillStyle = '#FFFF00';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('EXIT', platform.x + platform.width/2, platform.y + 15);
            }
        });
        
        // Draw stars
        stars.forEach(star => {
            if (!star.collected || star.scale > 0) {
                drawStar(star.x, star.y, 5, star.radius * star.scale, star.radius * 0.4 * star.scale);
            }
        });
        
        // Draw enemies
        enemies.forEach(enemy => {
            const enemyGradient = ctx.createRadialGradient(
                enemy.x, enemy.y, 2,
                enemy.x, enemy.y, enemy.size
            );
            enemyGradient.addColorStop(0, '#FF6666');
            enemyGradient.addColorStop(1, '#CC0000');
            
            ctx.fillStyle = enemyGradient;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y - enemy.size);
            ctx.lineTo(enemy.x + enemy.size, enemy.y + enemy.size);
            ctx.lineTo(enemy.x - enemy.size, enemy.y + enemy.size);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        });
        
        // Draw player
        if (gameState !== 'gameOver') {
            const playerGradient = ctx.createRadialGradient(
                player.x, player.y, 2,
                player.x, player.y, player.radius
            );
            playerGradient.addColorStop(0, '#FFFFFF');
            playerGradient.addColorStop(1, '#87CEEB');
            
            ctx.fillStyle = playerGradient;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }
        
        // Draw UI
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '20px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Score: ${score + (level-1) * 5}`, 20, 30);
        ctx.fillText(`Lives: ${player.lives}`, 20, 60);
        ctx.fillText(`Level: ${level}`, 20, 90);
        
        // Draw game state messages
        if (gameState === 'levelComplete') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Get ready for level: ${level + 1}`, canvas.width/2, canvas.height/2);
            ctx.fillText('Press SPACE to continue', canvas.width/2, canvas.height/2 + 40);
        } else if (gameState === 'gameOver') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FF0000';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '30px Arial';
            ctx.fillText('Press SPACE to restart', canvas.width/2, canvas.height/2 + 40);
        }
    }

    function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        const starGradient = ctx.createRadialGradient(cx, cy, 2, cx, cy, outerRadius);
        starGradient.addColorStop(0, '#FFFFCC');
        starGradient.addColorStop(1, '#FFCC00');
        
        ctx.fillStyle = starGradient;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        let step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    function lightenColor(color, percent) {
        const num = parseInt(color.slice(1), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return `#${(1 << 24 | R << 16 | G << 8 | B).toString(16).slice(1)}`;
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // Start game
    init();
    gameLoop();
</script>
</body>
</html>
