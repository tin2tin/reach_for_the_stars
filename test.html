<!DOCTYPE html>
<html>
<head>
    <title>Platform Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #222;
            overflow: hidden;
            font-family: Arial, sans-serif; /* Added for general text styling */
        }
        canvas {
            border: 2px solid #333;
            display: block; /* Ensures canvas doesn't have extra space below it */
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px; /* Space between buttons */
            z-index: 10; /* Ensure buttons are above canvas if overlapping */
        }
        .controls button {
            padding: 5px 10px;
            background: linear-gradient(to bottom, #ff6b6b, #c44d4d);
            border: 2px solid black;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap; /* Prevent text wrapping */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); /* Subtle shadow */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* Text shadow for buttons */
        }
        .controls button:hover {
            opacity: 0.9;
        }
        .controls button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <button id="restart">Restart</button>
        <button id="muteButton">Mute</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const restartButton = document.getElementById('restart');
        const muteButton = document.getElementById('muteButton');
        
        // --- Canvas Size (Full height, 40% width) ---
        canvas.width = window.innerWidth * 0.4;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth * 0.4;
            canvas.height = window.innerHeight;
            // Re-draw immediately after resize to avoid temporary blank screen
            draw(); 
        });
        
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            // For audio context initialization on first user interaction
            if (!audioCtxInitialized) {
                initAudioContext();
            }
        });
        window.addEventListener('keyup', e => keys[e.key] = false);
        restartButton.addEventListener('click', resetGame);
        
        let player = {
            x: 50,
            y: 50,
            radius: 15,
            vx: 0,
            vy: 0,
            onGround: false,
            lives: 3,
            scale: 1,
            justHitPlatform: false, // To prevent multiple bounce sounds on same platform
            invulnerable: false // For enemy collision cooldown
        };
        
        let platforms = [];
        let enemies = [];
        let stars = [];
        let exitPlatform = null;
        let score = 0;
        let level = 1;
        let gameState = 'playing';
        let platformSpeed = 0.6; // Slightly faster platforms
        let backgroundColors = [];

        // --- Audio Setup ---
        let audioCtx;
        let masterGainNode;
        let backgroundMusic;
        let isMuted = false;
        let audioCtxInitialized = false;

        function initAudioContext() {
            if (audioCtxInitialized) return; // Prevent re-initialization

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGainNode = audioCtx.createGain();
            masterGainNode.connect(audioCtx.destination);
            masterGainNode.gain.value = isMuted ? 0 : 1; // Set initial volume based on mute state

            // Load and play background music
            backgroundMusic = new Audio('https://github.com/tin2tin/reach_for_the_stars/raw/refs/heads/main/Sip%20of%20Comfort.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.5; // Adjust music volume relative to master gain
            backgroundMusic.muted = isMuted; // Ensure music starts muted if button says so
            
            // To ensure music plays after user interaction (required by browsers)
            const playMusicOnce = () => {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                backgroundMusic.play().catch(e => console.warn("Music play failed:", e));
                document.removeEventListener('click', playMusicOnce);
                document.removeEventListener('keydown', playMusicOnce);
            };
            document.addEventListener('click', playMusicOnce, { once: true });
            document.addEventListener('keydown', playMusicOnce, { once: true });

            audioCtxInitialized = true;
        }

        muteButton.addEventListener('click', () => {
            isMuted = !isMuted;
            muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
            if (audioCtxInitialized) {
                masterGainNode.gain.value = isMuted ? 0 : 1;
            }
            if (backgroundMusic) {
                backgroundMusic.muted = isMuted; // Control HTMLAudioElement directly
            }
        });

        // --- Coded Sound Effects ---
        function playSound(type, options = {}) {
            if (!audioCtxInitialized || isMuted) return; // Don't play if muted or context not ready

            const {
                frequency = 440, // Base frequency
                duration = 0.1, // Duration in seconds
                oscType = 'sine', // Oscillator type: 'sine', 'square', 'sawtooth', 'triangle'
                volume = 0.5, // Max volume (0 to 1)
                attack = 0.01, // Attack time
                decay = 0.05, // Decay time
                endFrequency // For pitch bends
            } = options;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = oscType;
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode); // Connect to the master gain node for global volume control

            gainNode.gain.setValueAtTime(0, audioCtx.currentTime); // Start from 0 volume
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + attack);
            gainNode.gain.linearRampToValueAtTime(volume * 0.5, audioCtx.currentTime + attack + decay);


            if (endFrequency) {
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(endFrequency, audioCtx.currentTime + duration);
            } else {
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            }

            oscillator.start(audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            oscillator.stop(audioCtx.currentTime + duration + 0.05); // Give a little extra time for fade out
        }

        function playJumpSound() {
            playSound('jump', { frequency: 600, duration: 0.1, oscType: 'triangle', volume: 0.7 });
        }

        function playCollectStarSound() {
            // Ascending arpeggio
            playSound('star_note1', { frequency: 800, duration: 0.05, oscType: 'sine', volume: 0.6 });
            setTimeout(() => playSound('star_note2', { frequency: 1000, duration: 0.05, oscType: 'sine', volume: 0.6 }), 50);
            setTimeout(() => playSound('star_note3', { frequency: 1200, duration: 0.05, oscType: 'sine', volume: 0.6 }), 100);
        }

        function playPlayerDieSound() {
            // Descending, slightly noisy sound
            playSound('die', { frequency: 200, endFrequency: 50, duration: 0.3, oscType: 'square', volume: 0.8 });
            // Add a short burst of noise for impact
            const bufferSize = audioCtx.sampleRate * 0.1; // 0.1 second of noise
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1; // White noise
            }
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.5, audioCtx.currentTime); // Initial volume for noise
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1); // Fade out noise quickly
            noiseSource.connect(noiseGain);
            noiseGain.connect(masterGainNode);
            noiseSource.start();
        }

        function playLevelCompleteSound() {
            // Triumphant ascending arpeggio
            playSound('complete_note1', { frequency: 700, duration: 0.1, oscType: 'triangle', volume: 0.6 });
            setTimeout(() => playSound('complete_note2', { frequency: 900, duration: 0.1, oscType: 'triangle', volume: 0.6 }), 100);
            setTimeout(() => playSound('complete_note3', { frequency: 1200, duration: 0.2, oscType: 'sine', volume: 0.7 }), 200);
        }

        function playGameOverSound() {
            // Somber descending notes
            playSound('gameover_note1', { frequency: 300, duration: 0.2, oscType: 'sawtooth', volume: 0.8 });
            setTimeout(() => playSound('gameover_note2', { frequency: 200, duration: 0.3, oscType: 'square', volume: 0.8 }), 200);
            setTimeout(() => playSound('gameover_note3', { frequency: 100, duration: 0.4, oscType: 'sine', volume: 0.8 }), 500);
        }

        function playPlatformBounceSound() {
            playSound('bounce', { frequency: 220, duration: 0.08, oscType: 'square', volume: 0.4, endFrequency: 180 });
        }

        function generateBackgroundColors() {
            backgroundColors = [];
            switch (level % 5) {
                case 1: // Night dawn
                    backgroundColors = ['#0a1a40', '#4a4969', '#7f7f9c'];
                    break;
                case 2: // Morning
                    backgroundColors = ['#f9d423', '#ff4e50', '#fc913a'];
                    break;
                case 3: // Afternoon
                    backgroundColors = ['#36d1dc', '#5b86e5', '#3494e6'];
                    break;
                case 4: // Evening
                    backgroundColors = ['#ff9966', '#ff5e62', '#c84e89'];
                    break;
                case 0: // Night
                    backgroundColors = ['#141e30', '#243b55', '#1a2a3a'];
                    break;
            }
        }
        
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            backgroundColors.forEach((color, index) => {
                gradient.addColorStop(index / (backgroundColors.length - 1), color);
            });
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawCircleWithGradient(x, y, radius, color1, color2, scale = 1) {
            ctx.beginPath();
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * scale);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.fillStyle = gradient;
            ctx.arc(x, y, radius * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawRectWithGradient(x, y, width, height, color1, color2) {
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) / 2);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
        }
        
        function drawTriangleWithGradient(x, y, size, color1, color2) {
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size, y + size);
            ctx.lineTo(x + size, y + size);
            ctx.closePath();
            
            const centerX = x;
            const centerY = y;
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawStarWithGradient(x, y, radius, spikes, color1, color2, scale = 1) {
            let rot = Math.PI / 2 * 3;
            let cx = x;
            let cy = y;
            let step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(cx + Math.cos(rot) * radius * scale, cy + Math.sin(rot) * radius * scale);
            
            for (let i = 0; i < spikes; i++) {
                rot += step;
                let x_inner = cx + Math.cos(rot) * radius * scale * 0.4;
                let y_inner = cy + Math.sin(rot) * radius * scale * 0.4;
                ctx.lineTo(x_inner, y_inner);
                rot += step;
                let x_outer = cx + Math.cos(rot) * radius * scale;
                let y_outer = cy + Math.sin(rot) * radius * scale;
                ctx.lineTo(x_outer, y_outer);
            }
            ctx.closePath();
            
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius * scale);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // --- Draw Text with Outline ---
        function drawTextWithOutline(text, x, y, font, fillColor, outlineColor, outlineWidth, textAlign = 'center') {
            ctx.font = font;
            ctx.textAlign = textAlign;
            ctx.lineWidth = outlineWidth;
            ctx.strokeStyle = outlineColor;
            ctx.fillStyle = fillColor;

            ctx.strokeText(text, x, y);
            ctx.fillText(text, x, y);
        }
        
        function initLevel() {
            platforms = [];
            enemies = [];
            stars = [];
            exitPlatform = null;
            generateBackgroundColors();
            
            // Starting platform
            platforms.push({
                x: 20,
                y: 80,
                width: 100,
                height: 20,
                color1: '#006400',
                color2: '#004d00',
                static: true
            });
            
            // Moving platforms
            const numPlatforms = 8 + Math.floor(Math.random() * 4);
            const maxY = canvas.height * 0.9;
            const minY = 120;
            const stepY = (maxY - minY) / numPlatforms;
            
            for (let i = 0; i < numPlatforms; i++) {
                const width = 70 + Math.random() * 150;
                const x = Math.random() * (canvas.width - width);
                const y = minY + i * stepY;
                const direction = Math.random() > 0.5 ? 1 : -1;
                
                platforms.push({
                    x,
                    y,
                    width,
                    height: 15,
                    color1: '#00008B',
                    color2: '#000066',
                    static: false,
                    direction,
                    speed: platformSpeed * (0.8 + Math.random() * 0.4)
                });
                
                // Add enemy to some platforms
                if (Math.random() < 0.3) {
                    enemies.push({
                        x: x + width / 2,
                        y: y - 15, // Initial dummy value, updated in updateEnemies
                        size: 12,
                        platformIndex: platforms.length - 1
                    });
                }
            }
            
            // Red gutter platform
            platforms.push({
                x: 0,
                y: canvas.height - 20,
                width: canvas.width,
                height: 20,
                color1: '#8B0000',
                color2: '#660000',
                static: true,
                deadly: true
            });
            
            // Add stars
            const numStars = 5 + level;
            const maxStarY = canvas.height * 2/3;
            
            for (let i = 0; i < numStars; i++) {
                let valid = false;
                let starX, starY;
                
                while (!valid) {
                    starX = 20 + Math.random() * (canvas.width - 40);
                    starY = 20 + Math.random() * (maxStarY - 40);
                    valid = true;
                    
                    // Check if star is not on top of an enemy or other stars
                    for (const enemy of enemies) {
                        const dx = starX - enemy.x;
                        const dy = starY - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 30) { // Check collision with enemies
                            valid = false;
                            break;
                        }
                    }
                    if (valid) {
                        for (const existingStar of stars) {
                            const dx = starX - existingStar.x;
                            const dy = starY - existingStar.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < 40) { // Give some space between stars
                                valid = false;
                                break;
                            }
                        }
                    }
                }
                
                stars.push({
                    x: starX,
                    y: starY,
                    radius: 15,
                    scale: 1,
                    collected: false
                });
            }
            
            // Reset player position
            player.x = 50;
            player.y = 50;
            player.vx = 0;
            player.vy = 0;
            player.scale = 1;
            player.justHitPlatform = false; // Reset bounce flag
            player.invulnerable = false; // Reset invulnerability
        }
        
        function update() {
            if (gameState === 'playing') {
                updatePlayer();
                updatePlatforms();
                updateEnemies();
                updateStars();
                checkExitPlatform();
            } else if (gameState === 'levelComplete' && keys[' ']) {
                level++;
                platformSpeed += 0.1;
                gameState = 'playing';
                initLevel();
                // Sound for continuing to next level (optional, already played when reaching exit)
                // playLevelCompleteSound(); 
            } else if (gameState === 'gameOver' && keys[' ']) {
                resetGame();
                // Sound for restarting game (optional, already played when lives run out)
                // playGameOverSound(); 
            }
        }
        
        function updatePlayer() {
            // Horizontal movement
            if (keys.ArrowLeft) player.vx = Math.max(player.vx - 0.2, -3);
            else if (keys.ArrowRight) player.vx = Math.min(player.vx + 0.2, 3);
            else player.vx *= 0.9;
            
            player.x += player.vx;
            
            // Jumping (Slightly higher jumps)
            if (keys[' '] && player.onGround) {
                player.vy = -8.5; // Increased jump height
                player.onGround = false;
                player.justHitPlatform = false; // Reset to allow next bounce sound on new landing
                playJumpSound();
            }
            
            // Gravity
            player.vy += 0.3;
            player.y += player.vy;
            
            // Boundary check
            if (player.x < player.radius) {
                player.x = player.radius;
                player.vx = 0;
            }
            if (player.x > canvas.width - player.radius) {
                player.x = canvas.width - player.radius;
                player.vx = 0;
            }
            
            // Platform collision
            let wasOnGround = player.onGround; // Store previous onGround state
            player.onGround = false; // Assume not on ground initially
            for (const platform of platforms) {
                // Check for general overlap
                if (player.y + player.radius > platform.y && 
                    player.y - player.radius < platform.y + platform.height &&
                    player.x + player.radius > platform.x && 
                    player.x - player.radius < platform.x + platform.width) {
                    
                    // Top collision (landing on platform)
                    if (player.vy >= 0 && player.y <= platform.y + player.radius) { // Check if falling onto it or exactly on top
                        player.y = platform.y - player.radius; // Position player on top
                        player.vy = -player.vy * 0.2; // Small bounce effect
                        player.onGround = true;

                        // Play bounce sound only if just landed and not already bouncing on this platform
                        if (!wasOnGround && !player.justHitPlatform) {
                           playPlatformBounceSound();
                           player.justHitPlatform = true; // Mark that player just bounced on a platform
                        }
                        
                        // Squeeze animation
                        player.scale = 0.9;
                        setTimeout(() => player.scale = 1, 100);
                        
                        // Move with platform
                        if (!platform.static) {
                            player.x += platform.direction * platform.speed;
                        }
                        
                        // Check if deadly platform
                        if (platform.deadly) {
                            playerDie();
                        }
                    } 
                    // Bottom collision (hitting head on platform)
                    else if (player.vy < 0 && player.y - player.radius < platform.y + platform.height && player.y > platform.y) {
                        player.y = platform.y + platform.height + player.radius; // Push player below platform
                        player.vy = 0; // Stop upward movement
                    }
                }
            }
            // If the player is no longer detected as onGround, reset the justHitPlatform flag
            // This ensures the bounce sound can play again when landing on a *new* platform or re-landing
            if (!player.onGround) {
                player.justHitPlatform = false;
            }

            // Enemy collision
            // Only check for collisions if player is not invulnerable
            if (!player.invulnerable) {
                for (const enemy of enemies) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.radius + enemy.size * 0.8) { // 0.8 factor for a slightly more forgiving hitbox
                        playerDie();
                        // Invulnerability is set inside playerDie()
                        break; // Only register one hit per invulnerability period
                    }
                }
            }
            
            // Fall off screen (deadly area beyond the red gutter)
            if (player.y > canvas.height + 50) {
                playerDie();
            }
        }
        
        function updatePlatforms() {
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                if (!platform.static) {
                    platform.x += platform.direction * platform.speed;
                    
                    // Reverse direction at edges
                    if (platform.x <= 0 || platform.x + platform.width >= canvas.width) {
                        platform.direction *= -1;
                    }
                }
            }
        }
        
        function updateEnemies() {
            for (const enemy of enemies) {
                const platform = platforms[enemy.platformIndex];
                // Enemy follows platform's X, but stays above it
                enemy.x = platform.x + platform.width / 2;
                enemy.y = platform.y - enemy.size * 1.5; // Position above platform, adjusted for size
            }
        }
        
        function updateStars() {
            let allCollected = true;
            
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                
                if (!star.collected) {
                    allCollected = false;
                    
                    const dx = player.x - star.x;
                    const dy = player.y - star.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.radius + star.radius * star.scale * 0.7) {
                        star.collected = true;
                        score += 1;
                        playCollectStarSound();
                        
                        // Animate star collection (shrinking effect)
                        (function animateStar(starIndex, scaleValue) {
                            stars[starIndex].scale = scaleValue;
                            if (scaleValue > 0.1) {
                                requestAnimationFrame(() => animateStar(starIndex, scaleValue - 0.1));
                            }
                        })(i, 1);
                    }
                }
            }
            
            if (allCollected && !exitPlatform) {
                // If all stars are collected, spawn the exit platform
                exitPlatform = {
                    x: canvas.width - 120,
                    y: canvas.height - 80,
                    width: 100,
                    height: 20,
                    color1: '#006400',
                    color2: '#004d00',
                    static: true
                };
            }
        }
        
        function playerDie() {
            // Ensure only one life is subtracted per hit, and player is temporarily invulnerable
            if (player.invulnerable) return; // Already hit and in invulnerable state
            
            player.lives--;
            playPlayerDieSound();
            player.invulnerable = true; // Set invulnerability
            setTimeout(() => { player.invulnerable = false; }, 1000); // Remove invulnerability after 1 second

            if (player.lives <= 0) {
                gameState = 'gameOver';
                playGameOverSound(); // Play game over sound when lives run out
            } else {
                // Animate player shrinking on hit/death
                (function animatePlayerDeath(scale) {
                    player.scale = scale;
                    if (scale > 0.1) {
                        requestAnimationFrame(() => animatePlayerDeath(scale - 0.1));
                    } else {
                        // Reset player position and state after animation
                        player.x = 50;
                        player.y = 50;
                        player.vx = 0;
                        player.vy = 0;
                        player.scale = 1;
                        player.justHitPlatform = false; // Reset bounce flag for new start
                    }
                })(1);
            }
        }
        
        function checkExitPlatform() {
            if (exitPlatform) {
                if (player.y + player.radius > exitPlatform.y && 
                    player.y - player.radius < exitPlatform.y + exitPlatform.height &&
                    player.x + player.radius > exitPlatform.x && 
                    player.x - player.radius < exitPlatform.x + exitPlatform.width) {
                    
                    // Only transition to level complete once
                    if (gameState !== 'levelComplete') {
                        gameState = 'levelComplete';
                        score += 5; // 5 points for completing level
                        playLevelCompleteSound(); // Play sound when reaching exit
                    }
                }
            }
        }
        
        function draw() {
            drawBackground();
            
            // Draw platforms
            for (const platform of platforms) {
                drawRectWithGradient(platform.x, platform.y, platform.width, platform.height, platform.color1, platform.color2);
            }
            
            // Draw exit platform
            if (exitPlatform) {
                drawRectWithGradient(exitPlatform.x, exitPlatform.y, exitPlatform.width, exitPlatform.height, exitPlatform.color1, exitPlatform.color2);
                
                // Draw EXIT text with outline
                drawTextWithOutline('EXIT', exitPlatform.x + exitPlatform.width / 2, exitPlatform.y + exitPlatform.height / 2 + 5, 'bold 16px Arial', 'yellow', 'black', 3);
            }
            
            // Draw stars
            for (const star of stars) {
                if (!star.collected) {
                    drawStarWithGradient(star.x, star.y, star.radius, 5, '#FFFF00', '#FFD700', star.scale);
                }
            }
            
            // Draw enemies
            for (const enemy of enemies) {
                drawTriangleWithGradient(enemy.x, enemy.y, enemy.size, '#FF0000', '#8B0000');
            }
            
            // Draw player
            drawCircleWithGradient(player.x, player.y, player.radius, '#FFFFFF', '#87CEEB', player.scale);
            
            // Draw UI (Text with outline)
            drawTextWithOutline(`Score: ${score}`, 10, 20, 'bold 16px Arial', 'white', 'black', 3, 'left');
            drawTextWithOutline(`Level: ${level}`, 10, 40, 'bold 16px Arial', 'white', 'black', 3, 'left');
            drawTextWithOutline(`Lives: ${'❤️'.repeat(player.lives)}`, 10, 60, 'bold 16px Arial', 'white', 'black', 3, 'left');
            
            // Draw game state messages (Text with outline)
            if (gameState === 'levelComplete') {
                drawTextWithOutline(`Get ready for level: ${level + 1}`, canvas.width / 2, canvas.height / 2, 'bold 24px Arial', 'white', 'black', 4);
                drawTextWithOutline('Press SPACE to continue', canvas.width / 2, canvas.height / 2 + 30, 'bold 24px Arial', 'white', 'black', 4);
            } else if (gameState === 'gameOver') {
                drawTextWithOutline('GAME OVER', canvas.width / 2, canvas.height / 2, 'bold 32px Arial', 'red', 'black', 5);
                drawTextWithOutline('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 40, 'bold 32px Arial', 'red', 'black', 5);
            }
        }
        
        function resetGame() {
            player.lives = 3;
            score = 0;
            level = 1;
            platformSpeed = 0.6; // Reset to initial faster speed
            gameState = 'playing';
            initLevel();
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Initial setup
        initLevel();
        gameLoop();
    </script>
</body>
</html>
